<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><meta charSet="utf-8"/><meta name="description" content="杨恒利个人网站 - 专注前端开发和可视化技术的工程师"/><meta name="keywords" content="前端开发,React,Vue,数据可视化,地图应用,无人机控制系统"/><meta name="author" content="杨恒利"/><link rel="icon" href="/favicon.ico"/><link rel="preload" href="/_next/static/css/d7cd8120df227820.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/d7cd8120df227820.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-68cecae4c417b0a0.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-491790abf9fc48ca.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-23cd4726963dec86.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/test-context-f17b90807987d604.js" defer="" crossorigin=""></script><script src="/_next/static/YLixRe5HA1IHXwh3d8BpZ/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/YLixRe5HA1IHXwh3d8BpZ/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div style="padding:10px;margin:10px;border:2px solid #ff6b6b;background-color:#ffe6e6"><h3>MessageProvider (渲染次数: <!-- -->1<!-- -->)</h3><p>变化的消息ID: <!-- -->0</p><p>变化的消息内容: <!-- -->初始消息</p><p>稳定的消息ID: <!-- -->999</p><p>稳定的消息内容: <!-- -->这是一个稳定的消息，不会变化</p><p>总消息数: <!-- -->0</p><div style="padding:20px;font-family:Arial, sans-serif"><h1>Context 重新渲染性能测试 Demo</h1><p>这个demo测试Context透传实时消息是否会导致所有子组件重新渲染</p><p>消息每1秒更新一次，请观察控制台输出和渲染次数</p><div style="margin-top:20px;padding:15px;background-color:#f8f9fa;border-radius:8px"><h2>测试结果说明：</h2><ul><li><strong>使用Context的子组件</strong>: 会在Context值变化时重新渲染</li><li><strong>不使用Context的子组件</strong>: 不会因为Context变化而重新渲染</li><li><strong>React.memo + 变化的数据</strong>: 不起作用！因为数据一直在变化（如message.id递增）</li><li><strong>React.memo + 稳定的数据</strong>: 起作用！当数据真正稳定时，memo可以避免重新渲染</li><li><strong>React.memo + Props传递</strong>: 真正起作用！通过props传递数据可以避免不必要的重新渲染</li><li><strong>useMemo</strong>: 可以优化渲染性能，减少重复计算</li><li><strong>选择性订阅</strong>: 只订阅需要的Context值，减少不必要的重新渲染</li></ul></div><div style="margin-top:20px"><div style="padding:15px;margin:15px;border:2px solid #2c3e50;background-color:#34495e;color:white"><h3>性能监控面板</h3><div style="display:grid;grid-template-columns:repeat(2, 1fr);gap:10px"></div></div><div style="padding:10px;margin:10px;border:1px solid #4ecdc4;background-color:#e0f9f6"><h3>子组件1 (使用Context) - 渲染次数: <!-- -->1</h3><p>消息ID: <!-- -->0</p><p>消息内容: <!-- -->初始消息</p><p>消息类型: <!-- -->system</p></div><div style="padding:10px;margin:10px;border:1px solid #45b7d1;background-color:#e0f4f8"><h3>子组件2 (使用Context + 更新功能) - 渲染次数: <!-- -->1</h3><p>消息ID: <!-- -->0</p><p>消息内容: <!-- -->初始消息</p><p>消息类型: <!-- -->system</p><button>手动更新消息</button></div><div style="padding:10px;margin:10px;border:1px solid #96ceb4;background-color:#e8f5e8"><h3>子组件3 (不使用Context) - 渲染次数: <!-- -->1</h3><p>本地状态: <!-- -->0</p><button>增加本地状态</button></div><div style="padding:10px;margin:10px;border:1px solid #feca57;background-color:#fff9e0"><h3>优化子组件 (使用React.memo) - 渲染次数: <!-- -->1</h3><p>消息ID: <!-- -->0</p><p>消息内容: <!-- -->初始消息</p><p>消息类型: <!-- -->system</p></div><div style="padding:10px;margin:10px;border:2px solid #ff6b35;background-color:#fff4e6"><h3>Memoized Props包装器 - 渲染次数: <!-- -->1</h3><div style="padding:10px;margin:10px;border:1px solid #ff6b35;background-color:#fff4e6"><h3>Memoized Props组件 (真正展示memo效果) - 渲染次数: <!-- -->1</h3><p>消息ID: <!-- -->0</p><p>消息内容: <!-- -->初始消息</p><p>消息类型: <!-- -->system</p></div></div><div style="padding:10px;margin:10px;border:1px solid #2ecc71;background-color:#e8f8f5"><h3>稳定Memo组件 (使用稳定message) - 渲染次数: <!-- -->1</h3><p>消息ID: <!-- -->999</p><p>消息内容: <!-- -->这是一个稳定的消息，不会变化</p><p>消息类型: <!-- -->system</p><p style="color:#27ae60;font-weight:bold">✅ 这个组件应该很少重新渲染，因为stableMessage不会变化</p></div><div style="padding:10px;margin:10px;border:1px solid #54a0ff;background-color:#e0f0ff"><h3>选择性订阅组件 (只订阅messageCount) - 渲染次数: <!-- -->1</h3><p>总消息数: <!-- -->0</p><p>注意: 这个组件只订阅messageCount，不会因为message内容变化而重新渲染</p></div><div style="padding:10px;margin:10px;border:1px solid #ff9ff3;background-color:#ffe0f8"><h3>Memoized子组件 (使用useMemo) - 渲染次数: <!-- -->1</h3><div><p>消息ID: <!-- -->0</p><p>消息内容: <!-- -->初始消息</p><p>消息类型: <!-- -->system</p></div></div></div><div style="margin-top:20px;padding:15px;background-color:#fff3cd;border-radius:8px"><h3>优化建议：</h3><ol><li>将Context拆分为多个小的Context，避免一个Context变化影响所有组件</li><li>使用React.memo包装通过props接收数据的组件（对直接订阅Context的组件无效）</li><li>使用useMemo缓存计算结果和JSX</li><li>只订阅需要的Context值，避免订阅整个Context对象</li><li>考虑使用状态管理库（如Redux、Zustand）替代Context</li><li>通过props传递数据而不是直接订阅Context，这样React.memo才能起作用</li><li><strong>关键点</strong>: React.memo只有在数据真正稳定时才起作用，如果数据一直在变化（如递增的ID），memo就无效</li></ol></div><div style="margin-top:20px;padding:15px;background-color:#e8f4fd;border-radius:8px"><h3>🔍 为什么React.memo不起作用？</h3><p><strong>你的观察完全正确！</strong></p><ul><li><strong>数据一直在变化</strong>: message.id 每秒都在递增，导致每次都是新的对象</li><li><strong>React.memo的浅比较</strong>: 当props/context值变化时，memo无法阻止重新渲染</li><li><strong>Context订阅机制</strong>: 直接订阅Context的组件在Context变化时会强制重新渲染</li></ul><p><strong>解决方案</strong>:</p><ul><li>使用稳定的数据（如stableMessage）</li><li>通过props传递数据而不是直接订阅Context</li><li>只订阅真正需要的Context值</li><li>使用useMemo缓存计算结果</li></ul></div></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{}},"page":"/test-context","query":{},"buildId":"YLixRe5HA1IHXwh3d8BpZ","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>